# Ch.02 컴퓨터의 구조와 성능 향상

## 하드웨어의 구성
- 필수 장치
  - 중앙처리 장치(CPU)
  - 메인 메모리
- 주변 장치
  - 입력장치
  - 출력장치
  - 저장장치

### CPU & 메모리
- CPU는 명령어를 해석하여 실행하는 장치, 인간으로 치면 두뇌에 해당
- 메모리는 작업에 필요한 프로그램과 데이터를 저장하는 장소로, **바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분한다**

### 입출력장치
- 입력장치
  - 외부의 데이터를 컴퓨터에 입력하는 장치
  - ex) 키보드, 마우스, 스캐너
- 출력장치
  - 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치
  - ex) 프린터, 모니터, 스피커

### 저장장치
- 구동장치가 있는 기계식 -> 전자의 이동으로 데이터를 처리하는 메모리에 비해 속도가 느리다
- 속도가 느려도 가격이 저렴하기 때문에 대용량 데이터를 저장하는 용도로 사용
- 또한 반영구적으로 데이터를 저장한다.

### 메인보드
- CPU와 메모리 등 다양한 부품을 연결하고 전원을 공급해주는 커다란 판
- 메인보드에서 각 장치를 연결하여 데이터가 지나다니는 통로를 `버스(bus)`라고 한다.

## 폰노이만 구조
- 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다.
- 가장 중요한 특징은 `모든 프로그램은 메모리에 올라와야 실행할 수 있다`는 것이다.
- 하드웨어는 그대로 둔 채 작업을 위한 프로그램만 교체하여 메모리에 올리는 방식

## 기초 용어 정리

### 크기 단위

| 단위               | 표기  | 2진 크기 | 10진 크기 | 바이트 대비 크기              | 10진 단위 |
|------------------|-----|------|--------|------------------------|--------|
| Byte(바이트)        | B   | 1    | 1      | 1B                     ||
| Kilo Byte(킬로바이트) | KB  | 2¹⁰  | 10³    | 1,000B                 | 천      |
| Mega Byte(메가바이트) | MB  | 2²⁰  | 10⁶    | 1,000,000B             | 백만     |
| Giga Byte(기가바이트) | GB  | 2³⁰  | 10⁹    | 1,000,000,000B         | 십억     |
| Tera Byte(테라바이트) | TB  | 2⁴⁰  | 10¹²   | 1,000,000,000,000B     | 조      |
| Peta Byte(페타바이트) | PB  | 2⁵⁰  | 10¹⁵   | 1,000,000,000,000,000B | 천조     |

### 클럭과 헤르츠
- 클럭(clock)이란 CPU의 속도를 나타내는 단위. 클럭은 1초 동안 파장이 한 번 움직이는 시간을 의미하는데, 이 시간 동안 처리하는 데이터 양에 따라 CPU의 속도가 달라진다.
- 하드디스크에서 데이터를 메모리로 옮기는 작업도 클럭에 맞추어 진행된다.
- 메모리에서 데이터를 가져오거나 저장할 때도 마찬가지다
- 헤르츠(Hz)는 시간에 따라 변화가 일어날 때 사용하는 단위
- 컴퓨터에서 헤르츠는 1초 동안 몇 번의 작업이 이루어져서 몇 번의 클록 틱이 발생하였는가를 의미한다.

### 시스템 버스 & CPU 버스
- 시스템 버스는 메모리와 주변장치를 연결하는 버스
- FSB(Front Side Bus) 혹은 전면버스라고 부름
- CPU 내부에도 다양한 장치들이 있는데 이들은 CPU 내부 버스로 연결된다.
- CPU 내부에 있는 장치를 연결하는 버스를 BSB(Back Side Bus) 혹은 후면 버스라고 부름

## CPU의 기본 구성
- 산술 논리 연산장치 (ALU, Arithmetic and Logic Unit)
  - CPU에서 데이터를 연산하는 장치
  - 데이터의 덧셈, 뺄셈, 곱셈, 나눗셈 같은 산술 연산과 AND, OR, XOR같은 논리 연산을 수행
- 제어장치
  - CPU에서 작업을 지시하는 부분
- 레지스터
  - CPU에서 작업할 데이터를 CPU내부에 보관하는 곳

## CPU의 명령어 처리 과정

## 레지스터의 종류 (CPU 제조사나 공정에 따라 다를 수 있음)
- 데이터 레지스터 또는 일반, 범용 레지스터 (Data Register)
- 주소 레지스터 (Address Register)
- 프로그램 카운터 (Program Counter)
- 명령어 레지스터 (Instruction Register)
- 메모리 주소 레지스터 (Memory Address Register)
- 메모리 버퍼 레지스터 (Memory Buffer Register)
- 프로그램 상태 레지스터 또는 플래그 레지스터 (Program Status Register)

| 레지스터    |              | 특징                                         |
|---------|--------------|--------------------------------------------|
| 일반 레지스터 | 데이터 레지스터     | CPU가 명령어를 처리하는 데 필요한 데이터를 임시로 저장하는 범용 레지스터 |
| 일반 레지스터 | 주소 레지스터      | 데이터 또는 명령어가 저장된 메모리의 주소를 저장                |
| 특수 레지스터 | 프로그램 카운터     | 다음에 실행할 명령어의 위치(코드의 행 번호)를 저장              |
| 특수 레지스터 | 명령어 레지스터     | 현재 실행 중인 명령어를 저장                           |
| 특수 레지스터 | 메모리 주소 레지스터  | 메모리 관리자가 접근해야 할 메모리 주소를 저장                 |
| 특수 레지스터 | 메모리 버퍼 레지스터  | 메모리 관리자가 메모리에서 가져온 데이터를 임시로 저장             |
| 특수 레지스터 | 프로그램 상태 레지스터 | 연산 결과(양수, 음수 등)를 저장                        |


- 메모리 관리자는 CPU의 레지스터에 직접 접근할 수 없다. 그래서 메모리 주소 레지스터와 메모리 버퍼 레지스터를 참조하여 데이터를 주고 받는다

## 버스의 종류


| 버스     | 특징                                                                                                       |
|--------|----------------------------------------------------------------------------------------------------------|
| 제어 버스  | 제어장치와 연결된 버스로, CPU가 메모리와 주변장치에 제어 신호를 보내기 위해 사용한다. 메모리와 주변 장치에서도 작업이 완료되거나 오류가 발생하면 제어 신호를 보내기 때문에 양방향이다 |
| 주소 버스  | 메모리 주소 레지스터와 연결된 버스로, 데이터를 읽거나 쓸 때 메모리나 주변 장치에 위치정보를 보내기 위해 사용하며 단방향이다                                   |
| 데이터 버스 | 메모리 버퍼 레지스터와 연결된 버스로 데이터의 이동이 양방향으로 이루어진다.                                                               |

![image](https://user-images.githubusercontent.com/85930725/222974586-8e1ea74e-b742-45e0-8776-e4826eccbeb1.png)

## CPU 비트의 의미
- 버스의 대역폭은 한 번에 전달할 수 있는 데이터의 최대 크기다.
- 흔히 32bit CPU, 64bit CPU라고 하는데 여기서의 32bit, 64bit는 CPU가 한 번에 처리할 수 있는 데이터의 최대 크기다
- 32bit CPU는 메모리에서 데이터를 읽거나 쓸 때 한 번에 최대 32bit를 처리할 수 있으며 이 경우 레지스터의 크기도 32bit, 버스의 대역폭도 32bit다.
- **버스의 대역폭, 레지스터의 크기, 메모리에 한 번에 저장할 수 있는 데이터의 크기는 항상 같다**

## 메모리 (혼자 공부하는 운영체제 참고함)
- 메모리를 이루는 소자 하나의 크기는 1bit로 0 또는 1이 저장된다. 그러나 소자 하나만으로 데이터를 표현할 수 없어 메모리 주소는 바이트 단위로 지정된다.

### 메모리의 종류

#### 휘발성 메모리
1. DRAM (Dynamic Ram)
   1. Dynamic RAM의 줄임말
   2. 저장된 데이터가 동적으로 변하는(사라지는) RAM -> 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
   3. 시간이 지나면 데이터가 사라지기 때문에 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성(다시 저장)해야 한다
   4. 이런 단점에도 불구하고, 일반적인 메모리는 DRAM을 사용 why? 소비 전력이 낮고, 저렴, 집적도가 높기 때문에 대용량으로 설계하기 용이
2. SRAM (Static Ram)
   1. Static RAM의 줄임말
   2. 저장된 데이터가 변하지 않는 RAM
   3. 일반적으로 DRAM보다 빠르다
   4. DRAM보다 집적도가 낮고, 소비 전력이 크며, 가격이 비쌈
   5. 캐시 메모리에 사용
3. SDRAM (Synchronous Dynamic Ram)
   1. SRAM과 관련없음
   2. 클럭 신호와 동기화된 발전된 형태의 DRAM -> 클럭 타이밍에 맞춰 CPU와 정보를 주고 받을 수 있음을 의미
4. DDR SDRAM (Double Data Rate SDRAM)
   1. 최근 가장 흔히 사용되는 RAM
   2. 대역폭을 넓혀 속도를 빠르게 만든 SDRAM

> DDR2는 DDR보다 2배, DDR3는 DDR보다 4배, DDR4는 DDR보다 8배 빠르다

![image](https://user-images.githubusercontent.com/85930725/222974578-96590f37-737c-4c64-b367-0af5b7b2903e.png)
- 다나와 RAM 판매 카테고리 이미지

#### 비휘발성 메모리
1. 플래시 메모리
   1. 디지털카메라, MP3 플레이어, USB 드라이버와 같이 전력이 없어도 데이터를 보관하는 저장장치에 사용
2. FRAM
3. PRAM
4. SSD

#### ROM
- 램과 달리 롬은 전력이 끊겨도 데이터를 보관할 수 있다는 것이 장점
- 데이터를 한 번 저장하면 바꿀 수 없다
- BIOS(BIOS : Basic Input / Output System)를 롬에 저장한다

1. 마스크 롬
   1. 데이터를 지우거나 쓸 수 없음
2. PROM
   1. 전용 기계를 이용하여 데이터를 한 번만 저장할 수 있음
3. EPROM
   1. 데이터를 여러 번 쓰고 지울 수 있음
   2. 플래시 메모리처럼 사용 가능하지만 가격이 비싸 잘 사용하지 않는다.

### 메모리 보호
- 메모리를 보호하기 위해 CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터에 저장한 후 작업한다
- 현재 작업 중인 작업이 차지하고 있는 메모리의 크기, 즉 마지막 주소까지의 차리를 한계 레지스터에 저장한다
- 사용자 작업이 진행되는 동안 이 두 레지스터의 주소 범위를 벗어나는지 하드웨어 측면에서 점검함으로써 메모리를 보호한다.

### 부팅
- 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정
1. 롬에 저장된 바이오스가 실행된다.
2. 주요 하드웨어 (CPU, 메모리, 저장장치, 키보드, 마우스)가 제대로 작동하는지 확인 및 점검
3. 운영체제가 설치된 저장장치(HDD/SDD) **마스터 부트 레코드**에 저장된 작은 프로그램을 메모리로 가져와 실행한다.
   1. 마스터 부트 레코드에는 운영체제를 실행하기 위한 코드인 부트스트랩이 저장되어 있다.
   2. 부트스트랩은 저장장치에 저장된 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램이다.
4. 운영체제가 메모리에 올라오고 실행된다.


## 컴퓨터 성능 향상 기술
- 현대 컴퓨터 구조의 가장 큰 문제는 CPU와 메모리, 주변장치의 작업 속도가 다르다는 것이다.
- 장치들간의 속도 차이를 개선하고 작업 속도를 올리기 위해 여러가지 기술들이 존재한다.

### 버퍼
- 버퍼는 두 장치 사이의 속도 차이를 완화하는 역할을 한다.
- 일정량의 데이터를 모아서 옮겨 속도 차이를 완화하는 장치
- 하드웨어에서만 사용하는 개념은 아니다. 
- 냉장고에 있는 귤 5개를 도마로 옮긴다고 가정
  - 한 번에 이동 시 귤 1개를 옮기는 것보다 하나의 바구니에 귤 5개를 담아서 가져오는 것이 효율적이다
  - 여기서 바구니가 버퍼의 기능과 유사하다.

### 스풀
- 버파와 비슷하지만 프로그램 간의 배타적으로 작동
- 서로 다른 프로그램 간에 버퍼를 공유하기 때문에 어떤 데이터이든 버퍼가 다 차면 이동이 시작된다. 하지만 스풀은 프로그램 간 배타적이기 때문에 공유되지 않는다
- ex) 프린트 출력

### 캐시
- 메모리와 CPU간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소.
- CPU가 앞으로 사용할 것으로 예상되는 데이터를 미리 가져다 놓는다.(prefetch)
- CPU 안에 있는 캐시는 CPU 내부 버스의 속도로 작동한다.
- 캐시 히트
  - CPU가 원하는 데이터를 캐시에서 찾는 경우
- 캐시 적중률 
  - 캐시가 히트되는 비율
- 캐시 미스
  - 캐시가 히트되지 않는 경우
- 컴퓨터의 성능을 향상하라면 캐시 적중률이 높아야함 
  - 방법 중 하나는 캐시의 크기를 늘리는 것 (캐시의 크기가 큰 CPU가 가격이 높다)
  - 지역성 이론 - 현재 실행중인 코드와 가까운 행에 있는 코드가 실행될 확률이 높음
- 캐시에 있는 데이터가 변경되는 이를 반영해야 하는 문제도 있음(메모리에 있는 데이터를 임시로 가져온 것이기 때문에 캐시에 있는 데이터가 변경되면 메모리에 있는 원본데이터도 변경해야 함)
  - 즉시 쓰기 방식(write through)
    - 캐시에 있는 데이터가 변경되면 이를 즉시 메모리에 반영
    - 메모리와의 빈번한 데이터 전송으로 성능이 느려진다는 단점
    - 메모리의 최신 값이 항상 유지되기 때문에 급작스러운 정전에도 데이터를 잃어버리지 않음
  - 지연 쓰기 방식 (copy back, wrtie back)
    - 캐시에 잇는 데이터가 변경되면 그 내용을 모아서 주기적으로 반영하는 방식
    - 성능을 향상 시킬 수 있지만 메모리와 캐시 간의 데이터 불일치가 생길 수도 있다
  
![image](https://user-images.githubusercontent.com/85930725/222974558-2d3380b3-ff37-490c-a846-74fac2907486.png)

### 저장 장치의 계층 구조
- 빠르고 값이 비싼 저장 장치를 CPU 가까운 쪽에 두고, 값이 싸고 용량이 큰 저장장치를 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 동시에 얻는 방법
- 저장장치의 계층 구조는 중복되는 데이터의 일관성을 유지하는 것이 문제 (해결 방법은 책에 안내되어 있지 않음)

### 인터럽트 (interrupt)
- 초기 컴퓨터 시스템은 CPU가 직접 입출력장치에서 데이터를 가져오는 방식인 폴링을 사용 -> 비효율적
- CPU 작업과 입출력 작업을 분리하여 효율을 높이는 방식, CPU는 입출력 관리자에게 작업을 지시하고, 입출력 관리자는 입출력이 끝나면 CPU에 인터럽트를 보낸다.
- 입출력 관리자가 CPU에 보내는 완료 신호를 인터럽트라고 함
- 인터럽트를 받은 CPU는 하던 일을 중단하고 옮겨진 데이터를 처리한다.

### 직접 메모리 접근 (Direct Memory Access)
- 입출력 관리자는 CPU가 요청한 데이터를 메모리에 가져다 좋아야 한다. 메모리는 CPU만 접근 권한을 가진 작업 공간이라 입출력 관리자는 접근이 불가하다. 따라서 입출력 관리자에게는 CPU의 허락 없이 메모리에 접근할 수 잇는 권한이 필요한데, 이것을 직접 메모리 접근이라고 한다.
- 데이터 전송을 지시받은 입출력 관리자는 직접 메모리 접근 권한이 있어야 CPU의 관여 없이 작업을 완료할 수 있다.

### 메모리 맵 입출력 (Memory Mapper I/O)
- 입출력 관리자(장치)가 사용하는 데이터, CPU가 사용하는 데이터가 섞여 있기 때문에 복잡함을 피하기 위해 도입된 방법
- CPU가 사용하는 메모리 공간과 직접 메모리 접근을 통해 들어오고 나가는 데이터를 위한 공간을 분리하는 것

### 사이클 훔치기 (Cycle Stealing)
- CPU와 직접 메모리 접근이 동시에 메모리에 접근하려 할 때 CPU가 메모리 사용 권한을 양보 (입출력 장치의 속도가 느리기 때문에)

## 멀티프로세싱

### 멀티코어 시스템
- 과거에는 컴퓨터 한 대에 하나의 CPU가 달린 시스템이였음 (단일 프로세서 시스템)
  - 싱글 프로세서 시스템에서의 성능향상은 CPU의 클록을 높이거나 캐시의 크기를 늘리는 것이다
  - CPU의 클록은 발열 문제로 인해 5GHz로 한계가 있음, 캐시도 비용문제 때문에 한계가 있음
- 이를 해결하기 위해 동시에 실행 가능한 명령의 개수를 늘리는 방법을 사용 (CPU 추가)
- 이를 멀티 프로세서(CPU) 시스템이라 부른다.
- 프로세서가 하나만 있는 단일 프로세서 시스템을 멀티 프로세서 시스템으로 바꾸기 위해서는 많은 설계 변경이 필요
- 이를 해결하기 위해 멀티 코어 시스템이 등장 (CPU의 핵심이 되는 코어를 추가하는 방식)

> 현재는 멀티 프로세서, 멀티 코어를 거의 동일하게 사용하는 곳이 많은 것 같음. 문맥 파악이 중요할 것으로 생각됨

### CPU 멀티스레드 (OS 스레드(네이티브 스레드)와는 다른 개념)
- 하나의 코어에서 2개 이상의 명령어를 처리하는 방법 (병렬 처리)
- ex) 인텔의 하이퍼 쓰레딩





