# Ch.09 가상 메모리 관리

## 01. 요구 페이징

### 01-01. 개요
- 운영체제는 필요한 모듈만 메모리에 올려 실행하고 나머지 모듈은 필요하다고 판단될 때 메모리로 불러오는데 이를 요구 페이징이라 한다.

### 01-02. 페이지 테이블의 엔트리 구조
- 접근 비트 : 접근 비트는 페이지가 메모리에 올라온 후 사용한 적이 있는 지 알려준다.
- 변경 비트 : 변경 비트는 페이지가 메모리에 올라온 후 데이터 변경이 있었는지 알려준다.
- 유효 비트 : 유효 비트는 페이지가 실제 메모리에 있는지를 나타낸다.
- 읽기 비트, 쓰기 비트, 실행 비트 : 피이지에 대한 읽기 권한, 쓰기 권한, 실행 권한을 나타낸다.

![image](https://github.com/hwibaski/book_study/assets/85930725/f8a04edd-f637-4d37-89c9-18aff92f96cf)

### 01-03. 페이지 부재
- 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 페이지 부재라고 한다. 페이지 부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다.

## 02. 페이지 교체 알고리즘

### 02-01. 개요
- 페이지 부재가 발생하면 스왑 영역에서 페이지를 메모리로 가져오는데, 만약 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑영역으로 보내야 한다.
- 페이지 교체 알고리즘은 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상한다.
### 02-02. 무작위 페이지 교체 알고리즘
- 스왑 영역으로 보낼 페이지를 특별한 로직 없이 무작위로 선정한다.
### 02-03. FIFO 페이지 교체 알고리즘
- 시간상 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아낸다. 성능은 좋지 않다.
### 02-04. 최적 페이지 교체 알고리즘
- 앞으로 사용하지 않을 페이지를 스왑 영역으로 보내는 이상적인 알고리즘이다. 구현은 불가능하다.
### 02-05. LRU 페이지 교체 알고리즘
- 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑영역으로 보낸다. 낭비되는 메모리 공간이 많다는 것이 단점
### 02-06. LFU 페이지 교체 알고리즘
- 페이지가 몇 번 사용되었는지를 기준으로 대상 페이지를 선정한다. 낭비되는 메모리 공간이 많다는 것이 단점.
### 02-07. NUR 페이지 교체 알고리즘
- LRU와 LFU와 성능이 비슷하면서도 불필요한 공간 낭비 문제를 해결한 알고리즘이다. 페이지마다 접근 비트와 변경 비트를 두고 (0, 0), (0, 1), (1,0), (1, 1)의 순서대로 스왑 영역으로 옮긴다.
### 02-08. FIFO 변형 알고리즘
#### 02-08-01. 2차 기회 페이지 교체 알고리즘
- 접근에 성공한 페이지를 큐의 맨 뒤로 이동시켜 접근 기회를 한 번 더 준다.
#### 02-08-02. 시계 페이지 교체 알고리즘
- 대상 페이지를 선정하는 포인터와 접근 비트가 있따. 대상 포인터가 가리키는 페이지가 스왑으로 옮겨지고, 해당 포인터는 아래쪽으로 이동한다. 접근 비트가 1이면 0으로 만들고 다시 한 칸 밑으로 이동한다.

## 03. 스레싱과 프레임 할당 (한빛미디어 유튜브 39강, 페이지 교체와 프레임 할당 참조)
### 03-01. 스레싱
- 프로세스가 많이 실행되고 하드디스크 입출력이 너무 많아져서 작업이 멈춘 것 같은 상태를 스레싱이라 한다.
- 동시에 실행하는 프로그램의 수를 멀티프로그래밍 정도라고 하는데, 멀티프로그래밍 정도가 너무 높으면 스레싱이 발생한다.
- 자주 사용하는 프로세스가 필요로 하는 메모리보다 물리 메모리가 작다면 스레싱 발생 지점에 빨리 도달하여 컴퓨터가 전체적으로 느려진다.
- 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 한다.
### 03-02. 정적 할당
- 프로세스 실행 초기에 프레임을 나누어 준 후 그 크기를 고정하는 방식이다. 균등 할당과 비례 할당이 있다.
- 균등 할당
  - 가장 단순한 할당 방식
  - 모든 프로세스들에게 균등하게 프레임을 할당하는 방식
- 비례 할당
  - 프로세스의 크기를 고려함
  - 프로세스 크기에 비례하여 프레임을 할당
  - 크기가 큰 프로세스인데 막상 실행해보니 많은 프레임을 필요로 하지 않는다? 크기가 작은 프로세스인데 막상 실행해보니 많은 프레임을 필요로 한다?
    - 결국 프로세스가 필요로 하는 프레임 수는 실행해봐야 안다.
### 03-03. 동적 할당
- 프로세스를 실행하는 중에 시시각각 변하는 요청에 따라 프레임을 나누어 주기도 하고 회수하기도 하는 방식이다. 작업 집합 모델을 사용하는 방식과 페이지 부재를 사용하는 방식이 있다.
- 작업 집합 모델 (working set model)
  - 프로세스가 실행하는 과정에서 배분할 프레임 결정
  - 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
    - 그렇다면 CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당
  - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
    - 작업 집합이란 "실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합"
- 페이지 부재 빈도 기반 
  - 프로세스가 실행하는 과정에서 배분할 프레임 결정
  - 두 개의 가정에서 생겨난 아이디어
    - 1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
    - 2. 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다.
  - 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식


### Reference
- https://www.youtube.com/watch?v=nF26uioM6zU

